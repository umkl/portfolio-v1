'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _promise = require('promise.defer');

var _promise2 = _interopRequireDefault(_promise);

var _pundleApi = require('pundle-api');

var _helpers = require('./helpers');

var _installer = require('./installer');

var _installer2 = _interopRequireDefault(_installer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var locks = new Map();
var name = '$steelbrain$npm$installer';
exports.default = (0, _pundleApi.createResolver)({
  name: name,
  callback: function callback(context, config, givenRequest, fromFile, cached, excluded) {
    return _asyncToGenerator(function* () {
      if (givenRequest.slice(0, 1) === '.' || _path2.default.isAbsolute(givenRequest)) {
        return null;
      }
      var newExcluded = excluded.concat([name]);

      try {
        var result = yield context.resolveAdvanced(givenRequest, fromFile, true, newExcluded);
        return result;
      } catch (_) {}

      var moduleName = (0, _helpers.getModuleName)(givenRequest);
      var lock = locks.get(moduleName);
      if (lock) {
        yield lock;
        return context.resolveAdvanced(givenRequest, fromFile, false, newExcluded);
      }
      if (!(0, _pundleApi.shouldProcess)(context.config.rootDirectory, fromFile, config)) {
        return null;
      }

      var deferred = (0, _promise2.default)();
      locks.set(moduleName, deferred.promise);
      try {
        yield context.resolveAdvanced(moduleName + '/package.json', fromFile, true, newExcluded);
        deferred.promise.resolve();
        return null;
      } catch (_) {}

      try {
        if (!config.silent) {
          context.report(new _pundleApi.MessageIssue('Installing \'' + moduleName + '\' in ' + context.config.rootDirectory, 'info'));
        }
        config.beforeInstall(moduleName);
        var error = null;
        try {
          yield _installer2.default.install(moduleName, config.save, context.config.rootDirectory);
        } catch (_) {
          error = _;
        }
        config.afterInstall(moduleName, error);
        if (error && !config.silent) {
          context.report(new _pundleApi.MessageIssue('Failed to install \'' + moduleName + '\'', 'error'));
        } else if (!error && !config.silent) {
          context.report(new _pundleApi.MessageIssue('Installed \'' + moduleName + '\' successfully', 'info'));
        }
      } finally {
        deferred.resolve();
      }
      return context.resolveAdvanced(givenRequest, fromFile, true, newExcluded);
    })();
  }
}, {
  save: false,
  silent: false,
  beforeInstall: function beforeInstall() {},
  afterInstall: function afterInstall() {},

  include: ['*'],
  exclude: [/(node_modules|bower_components)/]
}, false);