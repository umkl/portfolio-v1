'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _file = require('./file');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FileChunk = function () {
  function FileChunk(id, label) {
    _classCallCheck(this, FileChunk);

    (0, _assert2.default)(id && typeof id === 'number', 'id must be a string');
    (0, _assert2.default)(!label || typeof label === 'string', 'label must be a string');

    this.id = id;
    this.label = label || null;
    this.files = new Map();
    this.entries = [];
    this.imports = [];
  }

  _createClass(FileChunk, [{
    key: 'getId',
    value: function getId() {
      return this.id;
    }
  }, {
    key: 'getLabel',
    value: function getLabel() {
      return this.label;
    }
  }, {
    key: 'getIdOrLabel',
    value: function getIdOrLabel() {
      return this.label || this.id.toString();
    }
  }, {
    key: 'setFile',
    value: function setFile(filePath, file) {
      (0, _assert2.default)(filePath && typeof filePath === 'string', 'filePath must be a string');
      (0, _assert2.default)(file && (typeof file === 'undefined' ? 'undefined' : _typeof(file)) === 'object' && file.constructor.$pundle, 'file must be a valid Pundle File');

      this.files.set(filePath, file);
    }
  }, {
    key: 'setFiles',
    value: function setFiles(files) {
      var _this = this;

      (0, _assert2.default)(files && typeof files.forEach === 'function' && typeof files.keys === 'function', 'files must be a valid map');

      files.forEach(function (file, filePath) {
        _this.setFile(filePath, file);
      });
    }
  }, {
    key: 'getFile',
    value: function getFile(filePath) {
      return this.files.get(filePath);
    }
  }, {
    key: 'getFiles',
    value: function getFiles() {
      return this.files;
    }
  }, {
    key: 'clearFiles',
    value: function clearFiles() {
      this.files.clear();
    }
  }, {
    key: 'addEntry',
    value: function addEntry(fileEntry) {
      (0, _assert2.default)(fileEntry && (typeof fileEntry === 'undefined' ? 'undefined' : _typeof(fileEntry)) === 'object', 'entry must be a valid object');

      this.entries.push(fileEntry);
    }
  }, {
    key: 'removeEntry',
    value: function removeEntry(fileEntry) {
      (0, _assert2.default)(fileEntry && (typeof fileEntry === 'undefined' ? 'undefined' : _typeof(fileEntry)) === 'object', 'entry must be a valid object');

      var index = this.entries.indexOf(fileEntry);
      if (index !== -1) {
        this.entries.splice(index, 1);
      }
    }
  }, {
    key: 'getEntries',
    value: function getEntries() {
      return this.entries;
    }
  }, {
    key: 'clearEntries',
    value: function clearEntries() {
      this.entries = [];
    }
  }, {
    key: 'addImport',
    value: function addImport(fileImport) {
      (0, _assert2.default)(fileImport && (typeof fileImport === 'undefined' ? 'undefined' : _typeof(fileImport)) === 'object', 'import must be a valid object');

      this.imports.push(fileImport);
    }
  }, {
    key: 'removeImport',
    value: function removeImport(fileImport) {
      (0, _assert2.default)(fileImport && (typeof fileImport === 'undefined' ? 'undefined' : _typeof(fileImport)) === 'object', 'import must be a valid object');

      var index = this.imports.indexOf(fileImport);
      if (index !== -1) {
        this.imports.splice(index, 1);
      }
    }
  }, {
    key: 'getImports',
    value: function getImports() {
      return this.imports;
    }
  }, {
    key: 'clearImports',
    value: function clearImports() {
      this.imports = [];
    }
  }, {
    key: 'serialize',
    value: function serialize() {
      var id = this.id,
          label = this.label,
          imports = this.imports,
          entries = this.entries;


      return {
        version: 1,
        id: id,
        label: label,
        imports: imports,
        entries: entries
      };
    }
  }], [{
    key: 'unserialize',
    value: function unserialize(serialized) {
      (0, _assert2.default)(serialized && (typeof serialized === 'undefined' ? 'undefined' : _typeof(serialized)) === 'object', 'Serialized FileChunk must be an object');
      (0, _assert2.default)(serialized.version === 1, 'Serialized FileChunk version mismatch');

      var id = serialized.id,
          label = serialized.label,
          imports = serialized.imports,
          entries = serialized.entries;


      var fileChunk = new FileChunk(id, label);
      fileChunk.imports = imports;
      fileChunk.entries = entries;
      return fileChunk;
    }
  }]);

  return FileChunk;
}();

exports.default = FileChunk;