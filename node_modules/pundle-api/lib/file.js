'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FEATURES = exports.File = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _mergeSourceMap = require('merge-source-map');

var _mergeSourceMap2 = _interopRequireDefault(_mergeSourceMap);

var _fileChunk = require('./file-chunk');

var _fileChunk2 = _interopRequireDefault(_fileChunk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FEATURES = {
  ES_IMPORT: 'ES_IMPORT',
  ES_EXPORT: 'ES_EXPORT',
  CJS_IMPORT: 'CJS_IMPORT',
  CJS_EXPORT: 'CJS_EXPORT'
};

var features = new Set(Object.keys(FEATURES));

var File = (_temp = _class = function () {
  function File(filePath, contents, lastModified) {
    _classCallCheck(this, File);

    this.filePath = filePath;
    this.contents = contents;
    this.sourceMap = null;
    this.lastModified = lastModified;
    this.featuresUsed = new Set();
    this.sourceContents = contents;
    this.dependencyChunks = [];
    this.dependencyImports = [];
  }

  _createClass(File, [{
    key: 'useFeature',
    value: function useFeature(feature) {
      if (!features.has(feature)) {
        throw new Error('Unknown feature: ' + feature);
      }
      this.featuresUsed.add(feature);
    }
  }, {
    key: 'getFilePath',
    value: function getFilePath() {
      return this.filePath;
    }
  }, {
    key: 'getSource',
    value: function getSource() {
      return this.sourceContents;
    }
  }, {
    key: 'getContents',
    value: function getContents() {
      return this.contents.toString();
    }
  }, {
    key: 'getSourceMap',
    value: function getSourceMap() {
      return this.sourceMap;
    }
  }, {
    key: 'getLastModified',
    value: function getLastModified() {
      return this.lastModified;
    }
  }, {
    key: 'getChunks',
    value: function getChunks() {
      return this.dependencyChunks;
    }
  }, {
    key: 'setChunks',
    value: function setChunks(chunks) {
      if (!Array.isArray(chunks)) {
        throw new Error('Chunks must be an array');
      }
      this.dependencyChunks = chunks;
    }
  }, {
    key: 'addChunk',
    value: function addChunk(chunk) {
      (0, _assert2.default)(chunk && (typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === 'object', 'chunk must be a valid object');

      this.dependencyChunks.push(chunk);
    }
  }, {
    key: 'removeChunk',
    value: function removeChunk(chunk) {
      (0, _assert2.default)(chunk && (typeof chunk === 'undefined' ? 'undefined' : _typeof(chunk)) === 'object', 'chunk must be a valid object');

      var index = this.dependencyChunks.indexOf(chunk);
      if (index !== -1) {
        this.dependencyChunks.splice(index, 1);
      }
    }
  }, {
    key: 'getImports',
    value: function getImports() {
      return this.dependencyImports;
    }
  }, {
    key: 'setImports',
    value: function setImports(imports) {
      (0, _assert2.default)(Array.isArray(imports), 'Imports must be an array');

      this.dependencyImports = imports;
    }
  }, {
    key: 'addImport',
    value: function addImport(entry) {
      this.dependencyImports.push(entry);
    }
  }, {
    key: 'removeImport',
    value: function removeImport(fileImport) {
      (0, _assert2.default)(fileImport && (typeof fileImport === 'undefined' ? 'undefined' : _typeof(fileImport)) === 'object', 'chunk must be a valid object');

      var index = this.dependencyImports.indexOf(fileImport);
      if (index !== -1) {
        this.dependencyImports.splice(index, 1);
      }
    }
  }, {
    key: 'mergeTransformation',
    value: function mergeTransformation(contents, sourceMap) {
      if (this.sourceMap && !sourceMap) {
        this.sourceMap = null;
      } else if (!this.sourceMap && sourceMap) {
        this.sourceMap = sourceMap;
      } else if (this.sourceMap && sourceMap) {
        this.sourceMap = (0, _mergeSourceMap2.default)(this.sourceMap, sourceMap);
      }
      this.contents = contents;
    }
  }, {
    key: 'serialize',
    value: function serialize() {
      var filePath = this.filePath,
          contents = this.contents,
          sourceMap = this.sourceMap,
          lastModified = this.lastModified,
          featuresUsed = this.featuresUsed,
          sourceContents = this.sourceContents,
          dependencyChunks = this.dependencyChunks,
          dependencyImports = this.dependencyImports;


      return {
        version: 1,
        filePath: filePath,
        contents: contents.toString(),
        sourceMap: sourceMap,
        lastModified: lastModified,
        featuresUsed: Array.from(featuresUsed),
        sourceContents: sourceContents.toString('utf8'),
        dependencyChunks: dependencyChunks.map(function (c) {
          return c.serialize();
        }),
        dependencyImports: dependencyImports
      };
    }
  }], [{
    key: 'unserialize',
    value: function unserialize(serialized) {
      (0, _assert2.default)(serialized && (typeof serialized === 'undefined' ? 'undefined' : _typeof(serialized)) === 'object', 'Serialized File must be an object');
      (0, _assert2.default)(serialized.version === 1, 'Serialized File version mismatch');

      var filePath = serialized.filePath,
          contents = serialized.contents,
          sourceMap = serialized.sourceMap,
          lastModified = serialized.lastModified,
          featuresUsed = serialized.featuresUsed,
          sourceContents = serialized.sourceContents,
          dependencyChunks = serialized.dependencyChunks,
          dependencyImports = serialized.dependencyImports;


      var file = new File(filePath, Buffer.from(sourceContents), lastModified);
      file.contents = Buffer.from(contents);
      file.sourceMap = sourceMap;
      file.featuresUsed = new Set(featuresUsed);
      file.dependencyChunks = dependencyChunks.map(function (c) {
        return _fileChunk2.default.unserialize(c);
      });
      file.dependencyImports = dependencyImports;

      return file;
    }
  }]);

  return File;
}(), _class.$pundle = true, _temp);
exports.File = File;
exports.FEATURES = FEATURES;
exports.default = File;