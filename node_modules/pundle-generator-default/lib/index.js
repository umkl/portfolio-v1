'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _sourceMapToComment = require('source-map-to-comment');

var _sourceMapToComment2 = _interopRequireDefault(_sourceMapToComment);

var _pundleApi = require('pundle-api');

var _sourceMap = require('source-map');

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = (0, _pundleApi.createGenerator)(function () {
  var _ref = _asyncToGenerator(function* (context, config, chunk) {
    var entries = chunk.entries;
    var filesGenerated = [];
    var wrapperContents = yield Helpers.getWrapperContents(context, config);

    var chunks = [';(function() {', wrapperContents];
    var chunksMap = new _sourceMap.SourceMapGenerator({
      skipValidation: true
    });

    var linesCount = Helpers.getLinesCount(chunks.join('\n')) + 1;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = chunk.files.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var file = _step.value;

        var publicPath = Helpers.getFilePath(context, config, file.filePath);
        var fileContents = '__sbPundle.registerModule("' + publicPath + '", function(__filename, __dirname, require, module, exports) {\n' + file.getContents() + '\n});';
        var fileSourceMap = file.sourceMap;

        chunks.push(fileContents);
        filesGenerated.push(publicPath);

        if (config.sourceMap) {
          if (fileSourceMap) {
            var sourceMapPath = _path2.default.join('$' + config.sourceMapNamespace, _path2.default.relative(context.config.rootDirectory, file.filePath));
            Helpers.mergeSourceMap(fileSourceMap, chunksMap, 'pundle:///' + sourceMapPath, file.getSource().toString(), linesCount);
          }
          linesCount += Helpers.getLinesCount(fileContents);
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var mappings = Object.assign({}, config.mappings, {
      files: Object.assign({}, Helpers.getFileMappings(context, chunk, config), config.mappings.files)
    });
    chunks.push('__sbPundle.registerMappings(' + JSON.stringify(mappings) + ')');
    chunks.push('__sbPundle.registerLoaded(' + JSON.stringify(config.label) + ')');
    for (var i = 0, length = entries.length; i < length; i++) {
      (0, _assert2.default)(entries[i].resolved, 'Entry file \'' + entries[i].request + '\' was not resolved');
      chunks.push('__sbPundle.require(\'' + Helpers.getFilePath(context, config, entries[i].resolved) + '\')');
    }
    chunks.push('})();\n');

    var sourceMap = chunksMap.toJSON();
    if (config.sourceMap) {
      if (config.sourceMapPath === 'inline') {
        chunks.push((0, _sourceMapToComment2.default)(sourceMap));
      }
    }

    return {
      chunk: chunk,
      contents: chunks.join('\n'),
      sourceMap: sourceMap,
      filesGenerated: filesGenerated
    };
  });

  return function (_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}(), {
  label: '',
  wrapper: 'normal',
  pathType: 'filePath',
  mappings: {},
  sourceMap: false,
  bundlePath: '',
  publicRoot: '',
  sourceMapPath: null,
  sourceNamespace: 'app',
  sourceMapNamespace: 'app'
});