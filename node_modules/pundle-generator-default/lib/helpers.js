'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getWrapperContents = exports.wrapperNormal = exports.wrapperHMR = exports.numericPaths = exports.LINE_BREAK = undefined;

var getWrapperContents = exports.getWrapperContents = function () {
  var _ref = _asyncToGenerator(function* (context, config) {
    var wrapper = config.wrapper;
    if (wrapper === 'normal') {
      wrapper = wrapperNormal;
    } else if (wrapper === 'hmr') {
      wrapper = wrapperHMR;
    } else if (wrapper === 'none') {
      return '';
    }
    if (!_path2.default.isAbsolute(wrapper)) {
      wrapper = yield context.resolve(wrapper, null, false);
    }
    var fileContents = yield _sbFs2.default.readFile(wrapper);

    if (config.publicRoot && config.bundlePath) {
      var outputPath = _path2.default.join(config.publicRoot, _path2.default.basename(config.bundlePath));
      var outputPathExt = _path2.default.extname(outputPath);
      fileContents = fileContents.replace(/SB_PUNDLE_PUBLIC_PRE/g, JSON.stringify(outputPath.slice(0, -1 * outputPathExt.length))).replace(/SB_PUNDLE_PUBLIC_POST/g, JSON.stringify(outputPathExt));
    }
    return fileContents;
  });

  return function getWrapperContents(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.getLinesCount = getLinesCount;
exports.getFilePath = getFilePath;
exports.getFileMappings = getFileMappings;
exports.mergeSourceMap = mergeSourceMap;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _slash = require('slash');

var _slash2 = _interopRequireDefault(_slash);

var _sbFs = require('sb-fs');

var _sbFs2 = _interopRequireDefault(_sbFs);

var _sourceMap = require('source-map');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var LINE_BREAK = exports.LINE_BREAK = /\r\n|\n|\r/;
function getLinesCount(text) {
  return text.split(LINE_BREAK).length;
}

var nextNumericPath = 1;
var numericPaths = exports.numericPaths = new Map();
function getFilePath(context, config, filePath) {
  var toReturn = void 0;
  if (config.pathType === 'filePath') {
    toReturn = _path2.default.join('$' + config.sourceNamespace, _path2.default.relative(context.config.rootDirectory, filePath));
  } else {
    toReturn = numericPaths.get(filePath);
    if (!toReturn) {
      nextNumericPath++;
      numericPaths.set(filePath, toReturn = 'm-' + nextNumericPath);
    }
  }
  return (0, _slash2.default)(toReturn);
}

var wrapperHMR = exports.wrapperHMR = require.resolve('../wrappers/dist/hmr');
var wrapperNormal = exports.wrapperNormal = require.resolve('../wrappers/dist/normal');
function getFileMappings(context, chunk, config) {
  var mappings = {};

  function processImport(entry) {
    var filePath = getFilePath(context, config, entry.resolved || '');
    if (!mappings[filePath]) {
      mappings[filePath] = [];
    }
    mappings[filePath].push(entry.id);
  }
  chunk.files.forEach(function (file) {
    file.getImports().forEach(processImport);
    file.getChunks().forEach(function (childChunk) {
      childChunk.imports.forEach(processImport);
    });
  });
  return mappings;
}

function mergeSourceMap(sourceMap, target, filePath, sourceContents, offset) {
  var entryMap = new _sourceMap.SourceMapConsumer(sourceMap);
  for (var i = 0, length = entryMap._generatedMappings.length; i < length; i++) {
    var mapping = entryMap._generatedMappings[i];
    target.addMapping({
      source: filePath,
      original: { line: mapping.originalLine, column: mapping.originalColumn },
      generated: { line: offset + mapping.generatedLine, column: mapping.generatedColumn }
    });
  }
  target.setSourceContent(filePath, sourceContents);
}