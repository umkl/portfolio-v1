'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var copy = function () {
  var ref = _asyncToGenerator(function* (source, destination, options) {
    var sourceInfo = yield stat(source);
    var destinationInfo = yield stat(destination);
    if (!sourceInfo) {
      throw new Error('Source \'' + source + '\' doesn\'t exist');
    }
    if (!(yield stat(_path2.default.dirname(destination)))) {
      throw new Error('Parent directory of destination \'' + destination + '\' doesn\'t exist');
    }
    if (destinationInfo && (sourceInfo.isFile() || sourceInfo.isDirectory() && !destinationInfo.isDirectory())) {
      if (!options.overwrite) {
        if (options.failIfExists) {
          throw new Error('Destination \'' + destination + '\' already exists');
        }
        return;
      }
      yield remove(destination, {
        disableGlob: true
      });
      destinationInfo = null;
    }
    if (sourceInfo.isFile()) {
      yield new Promise(function (resolve, reject) {
        _fs2.default.createReadStream(source).pipe(_fs2.default.createWriteStream(destination, {
          mode: sourceInfo.mode
        }, { end: true })).on('error', reject).on('close', resolve);
      });
      options.tickCallback(source, destination);
      return;
    }
    if (sourceInfo.isSymbolicLink()) {
      yield link(destination, (yield readLink(source)));
      options.tickCallback(source, destination);
      return;
    }
    if (sourceInfo.isDirectory()) {
      var _ret = yield* function* () {
        if (!destinationInfo) {
          yield mkdir(destination, sourceInfo.mode);
        }
        var sourceContents = yield readdir(source);
        var destinationContents = yield readdir(destination);

        if (options.deleteExtra) {
          var filesToDelete = destinationContents.filter(function (item) {
            return sourceContents.indexOf(item) === -1;
          });
          yield Promise.all(filesToDelete.map(function (item) {
            return remove(_path2.default.join(destination, item), {
              disableGlob: true
            });
          }));
        }

        yield Promise.all(sourceContents.filter(function (item) {
          return options.filter(_path2.default.join(source, item), _path2.default.join(destination, item));
        }).map(function (item) {
          return copy(_path2.default.join(source, item), _path2.default.join(destination, item), options);
        }));
        options.tickCallback(source, destination);
        return {
          v: void 0
        };
      }();

      if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
    }
    throw new Error('Unable to determine type of \'' + source + '\'');
  });

  return function copy(_x, _x2, _x3) {
    return ref.apply(this, arguments);
  };
}();

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _rimraf = require('rimraf');

var _rimraf2 = _interopRequireDefault(_rimraf);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var link = (0, _sbPromisify2.default)(_fs2.default.link);
var stat = (0, _sbPromisify2.default)(_fs2.default.stat, false);
var mkdir = (0, _sbPromisify2.default)(_fs2.default.mkdir);
var remove = (0, _sbPromisify2.default)(_rimraf2.default);
var readdir = (0, _sbPromisify2.default)(_fs2.default.readdir);
var readLink = (0, _sbPromisify2.default)(_fs2.default.readlink);

function copyContent(source, destination) {
  var givenOptions = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  return copy(source, destination, (0, _helpers.fillOptions)(givenOptions));
}

module.exports = copyContent;