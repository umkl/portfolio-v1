'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sbFs = require('sb-fs');

var _sbFs2 = _interopRequireDefault(_sbFs);

var _pundleBrowser = require('pundle-browser');

var _pundleBrowser2 = _interopRequireDefault(_pundleBrowser);

var _pundleApi = require('pundle-api');

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function resolveInManifestAndAlias(request, alias, manifest, packageMains) {
  var chunks = void 0;
  var isDirectory = request.slice(-1) === '/';

  if ((0, _helpers.isModuleRequested)(request)) {
    chunks = request.split(_helpers.MODULE_SEPARATOR_REGEX);
  } else {
    chunks = [request];
  }
  var moduleName = chunks[0];

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = packageMains[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var packageMain = _step.value;

      var value = _typeof(manifest[packageMain]) === 'object' ? manifest[packageMain][moduleName] : undefined;
      if (typeof value === 'boolean' && value === false) {
        if ((0, _helpers.isModuleOnly)(request)) {
          chunks.length = 1;
          moduleName = _pundleBrowser2.default.empty;
          break;
        }
      } else if (typeof value === 'string') {
        moduleName = value;
        if (moduleName.slice(0, 1) === '.') {
          moduleName = _path2.default.resolve(manifest.rootDirectory, moduleName);
        }
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var aliasValue = alias[moduleName];
  if (typeof aliasValue === 'boolean' && aliasValue === false) {
    chunks.length = 1;
    moduleName = _pundleBrowser2.default.empty;
  } else if (typeof aliasValue === 'string') {
    moduleName = aliasValue;
  }
  chunks[0] = moduleName;

  var resolved = chunks.join('/');
  if (isDirectory) {
    resolved += '/';
  }
  return resolved;
}

exports.default = (0, _pundleApi.createResolver)(function () {
  var _ref = _asyncToGenerator(function* (context, config, givenRequest, fromFile, cached) {
    var request = givenRequest;
    var fromDirectory = '';
    var manifest = { rootDirectory: context.config.rootDirectory };
    var extensions = config.extensions || config.knownExtensions;
    var targetManifest = {};

    if (fromFile) {
      fromDirectory = _path2.default.dirname(fromFile);
      Object.assign(manifest, (yield (0, _helpers.getManifest)(fromDirectory, config, cached, context.config)));
    }

    if ((0, _helpers.isModuleRequested)(request)) {
      request = resolveInManifestAndAlias(request, config.alias, manifest, config.packageMains);
    }

    if ((0, _helpers.isModuleOnly)(request) && request !== 'empty' && _pundleBrowser2.default[request]) {
      return { filePath: _pundleBrowser2.default[request], sourceManifest: manifest, targetManifest: null };
    }
    var resolved = yield (0, _helpers.promisedResolve)(request, {
      basedir: fromDirectory || context.config.rootDirectory,
      extensions: extensions.map(function (i) {
        return '.' + i;
      }),
      readFile: function readFile(path, callback) {
        _sbFs2.default.readFile(path).then(function (result) {
          callback(null, result);
        }, function (error) {
          callback(error, null);
        });
      },
      isFile: function isFile(path, callback) {
        _sbFs2.default.stat(path).then(function (stats) {
          callback(null, stats.isFile());
        }, function () {
          callback(null, false);
        });
      },
      packageFilter: function packageFilter(packageManifest, manifestPath) {
        Object.assign(targetManifest, packageManifest, {
          rootDirectory: _path2.default.dirname(manifestPath)
        });
        if ((0, _helpers.isModuleOnly)(request)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = config.packageMains[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var packageMain = _step2.value;

              var value = packageManifest[packageMain];
              if (value && typeof value === 'string') {
                packageManifest.main = value;
                break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
        return packageManifest;
      },

      moduleDirectory: config.moduleDirectory
    });
    if (!resolved) {
      return null;
    }

    var manifestToUse = (0, _helpers.isModuleRequested)(request) ? targetManifest : manifest;
    var relative = _path2.default.relative(manifestToUse.rootDirectory, resolved);

    if (relative.substr(0, 3) !== '../' && relative.substr(0, 3) !== '..\\' && !_path2.default.isAbsolute(relative)) {
      resolved = resolveInManifestAndAlias('./' + relative, {}, manifestToUse, config.packageMains);
      resolved = _path2.default.resolve(manifestToUse.rootDirectory, resolved);
    }

    return {
      sourceManifest: manifest,
      targetManifest: targetManifest,
      filePath: resolved
    };
  });

  return function (_x, _x2, _x3, _x4, _x5) {
    return _ref.apply(this, arguments);
  };
}(), {
  alias: {},
  extensions: null,

  packageMains: ['browser', 'browserify', 'webpack', 'main'],
  modulesDirectories: ['node_modules']
});