'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _sbDebounce = require('sb-debounce');

var _sbDebounce2 = _interopRequireDefault(_sbDebounce);

var _sbFs = require('sb-fs');

var _sbFs2 = _interopRequireDefault(_sbFs);

var _lodash = require('lodash.differenceby');

var _lodash2 = _interopRequireDefault(_lodash);

var _pundleApi = require('pundle-api');

var _sbEventKit = require('sb-event-kit');

var _watcher = require('./watcher');

var _watcher2 = _interopRequireDefault(_watcher);

var _helpers = require('./helpers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Compilation = function () {
  function Compilation(context) {
    _classCallCheck(this, Compilation);

    this.context = context;
    this.subscriptions = new _sbEventKit.CompositeDisposable();
  }

  _createClass(Compilation, [{
    key: 'processFile',
    value: function () {
      var _ref = _asyncToGenerator(function* (filePath) {
        if (!_path2.default.isAbsolute(filePath)) {
          throw new Error('compilation.processFile() expects path to be an absolute path');
        }

        var contents = yield _sbFs2.default.readFile(filePath);
        var sourceStat = yield _sbFs2.default.stat(filePath);
        var file = new _pundleApi.File(filePath, contents, sourceStat.mtime.getTime() / 1000);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.context.getComponents('transformer')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var entry = _step.value;

            var transformerResult = yield this.context.invokeComponent(entry, 'callback', [], [file]);
            if (transformerResult) {
              file.mergeTransformation(transformerResult.contents, transformerResult.sourceMap);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var loaderResult = void 0;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.context.getComponents('loader')[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _entry = _step2.value;

            loaderResult = yield this.context.invokeComponent(_entry, 'callback', [], [file]);
            if (loaderResult) {
              file.mergeTransformation(loaderResult.contents, loaderResult.sourceMap);
              file.setChunks(file.getChunks().concat(loaderResult.chunks));
              file.setImports(file.getImports().concat(loaderResult.imports));
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (!loaderResult) {
          throw new _pundleApi.MessageIssue('No loader configured in Pundle for \'' + filePath + '\'. Try adding pundle-loader-js (or another depending on filetype) with appropriate settings to your configuration', 'error');
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.context.getComponents('plugin')[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _entry2 = _step3.value;

            yield this.context.invokeComponent(_entry2, 'callback', [], [file]);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        return file;
      });

      function processFile(_x) {
        return _ref.apply(this, arguments);
      }

      return processFile;
    }()
  }, {
    key: 'processFileTree',
    value: function () {
      var _ref2 = _asyncToGenerator(function* (entry, files, oldFiles, useCache) {
        var _this = this;

        var forceOverwrite = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var tickCallback = arguments[5];

        var resolved = void 0;
        if (typeof entry === 'string') {
          resolved = entry;
        } else {
          try {
            resolved = yield this.context.resolve(entry.request, entry.from, useCache);
            entry.resolved = resolved;
          } catch (error) {
            throw error;
          }
        }
        if (files.has(resolved) && !forceOverwrite) {
          return true;
        }

        var newFile = void 0;
        var currentFile = files.get(resolved);
        if (currentFile === null) {
          return true;
        }
        if (!currentFile && oldFiles.has(resolved) && useCache) {
          files.set(resolved, null);

          var fileStat = void 0;
          try {
            fileStat = yield _sbFs2.default.stat(resolved);
          } catch (_) {}
          var lastStateFile = oldFiles.get(resolved);
          if (lastStateFile && fileStat && fileStat.mtime.getTime() / 1000 === lastStateFile.lastModified) {
            newFile = lastStateFile;
          }
        }
        try {
          if (!newFile) {
            files.set(resolved, null);
            newFile = yield this.processFile(resolved);
          }
          yield Promise.all(newFile.getImports().map(function (item) {
            return _this.processFileTree(item, files, oldFiles, useCache, false, tickCallback);
          }));
          yield Promise.all(newFile.getChunks().map(function (item) {
            return Promise.all(item.imports.map(function (importEntry) {
              return _this.processFileTree(importEntry, files, oldFiles, useCache, false, tickCallback);
            }));
          }));
        } catch (error) {
          if (currentFile) {
            files.set(resolved, currentFile);
          } else {
            files.delete(resolved);
          }
          throw error;
        }
        yield tickCallback(currentFile, newFile);
        files.set(resolved, newFile);
        return true;
      });

      function processFileTree(_x2, _x3, _x4, _x5) {
        return _ref2.apply(this, arguments);
      }

      return processFileTree;
    }()
  }, {
    key: 'processChunk',
    value: function processChunk(chunk, files) {
      chunk.files.clear();
      function iterate(fileImport) {
        var filePath = fileImport.resolved;
        if (!filePath) {
          throw new Error(fileImport.request + ' was not resolved from ' + (fileImport.from || 'Project root'));
        }
        if (chunk.files.has(filePath)) {
          return;
        }
        var file = files.get(filePath);
        if (!file) {
          throw new Error(filePath + ' was not processed');
        }
        chunk.files.set(filePath, file);
        file.getImports().forEach(function (entry) {
          return iterate(entry);
        });
      }

      chunk.entries.forEach(function (entry) {
        return iterate(entry);
      });
      chunk.imports.forEach(function (entry) {
        return iterate(entry);
      });
    }
  }, {
    key: 'build',
    value: function () {
      var _ref3 = _asyncToGenerator(function* (useCache) {
        var _this2 = this;

        var oldFiles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();

        var files = new Map();
        var chunks = this.context.config.entry.map(function (request) {
          var chunk = _this2.context.getChunk();
          chunk.addEntry(_this2.context.getImportRequest(request));
          return chunk;
        });

        yield Promise.all(chunks.map(function (chunk) {
          return Promise.all(chunk.entries.map(function (chunkEntry) {
            return _this2.processFileTree(chunkEntry, files, oldFiles, useCache, false, function (_, file) {
              var fileChunks = file.getChunks();
              if (fileChunks.length) {
                chunks = chunks.concat(fileChunks);
              }
            });
          }));
        }));
        chunks.forEach(function (chunk) {
          return _this2.processChunk(chunk, files);
        });
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.context.getComponents('chunk-transformer')[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var entry = _step4.value;

            yield this.context.invokeComponent(entry, 'callback', [], [chunks]);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        return chunks;
      });

      function build(_x7) {
        return _ref3.apply(this, arguments);
      }

      return build;
    }()
  }, {
    key: 'watch',
    value: function () {
      var _ref4 = _asyncToGenerator(function* (useCache) {
        var _this3 = this;

        var oldFiles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();

        var queue = Promise.resolve();
        var chunks = this.context.config.entry.map(function (request) {
          var chunk = _this3.context.getChunk();
          chunk.addEntry(_this3.context.getImportRequest(request));
          return chunk;
        });

        var files = new Map();
        var watcher = new _watcher2.default({
          usePolling: this.context.config.watcher.usePolling
        });
        var disposable = new _sbEventKit.Disposable(function () {
          watcher.dispose();
          _this3.subscriptions.delete(disposable);
        });
        this.subscriptions.add(disposable);

        var enqueue = function enqueue(callback) {
          return queue = queue.then(callback).catch(function (e) {
            return _this3.context.report(e);
          });
        };
        var triggerRecompile = function () {
          var _ref5 = _asyncToGenerator(function* () {
            yield queue;
            var cloned = chunks.slice();
            cloned.forEach(function (chunk) {
              return _this3.processChunk(chunk, files);
            });
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = _this3.context.getComponents('chunk-transformer')[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var entry = _step5.value;

                yield _this3.context.invokeComponent(entry, 'callback', [], [cloned]);
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }

            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = _this3.context.getComponents('watcher')[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _entry3 = _step6.value;

                try {
                  yield _this3.context.invokeComponent(_entry3, 'compile', [], [cloned, files]);
                } catch (error) {
                  _this3.context.report(error);
                }
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          });

          return function triggerRecompile() {
            return _ref5.apply(this, arguments);
          };
        }();
        var tickCallback = function () {
          var _ref6 = _asyncToGenerator(function* (oldFile, file) {
            var oldChunks = oldFile ? oldFile.getChunks() : [];
            var newChunks = file.getChunks();
            var addedChunks = (0, _lodash2.default)(newChunks, oldChunks, _helpers.serializeChunk);
            var removedChunks = (0, _lodash2.default)(oldChunks, newChunks, _helpers.serializeChunk);
            var unchangedChunks = oldChunks.filter(function (chunk) {
              return removedChunks.indexOf(chunk) !== -1;
            });

            var oldImports = oldFile ? oldFile.getImports : [];
            var newImports = file.getImports();
            var addedImports = (0, _lodash2.default)(newImports, oldImports, _helpers.serializeImport);
            var removedImports = (0, _lodash2.default)(oldImports, newImports, _helpers.serializeImport);

            if (!oldFile && file) {
              watcher.watch(file.filePath);
            }

            removedChunks.forEach(function (entry) {
              var index = chunks.indexOf(entry);
              if (index !== -1) {
                chunks.splice(index, 1);
              }
            });
            addedChunks.forEach(function (entry) {
              chunks.push(entry);
            });
            addedImports.forEach(function (entry) {
              watcher.watch(entry.resolved);
            });
            removedImports.forEach(function (entry) {
              if (entry.resolved) {
                watcher.unwatch(entry.resolved);
              }
            });

            file.getChunks().forEach(function (chunk) {
              var matchingChunk = unchangedChunks.find(function (entry) {
                return (0, _helpers.serializeChunk)(entry) === (0, _helpers.serializeChunk)(chunk);
              });
              if (matchingChunk) {
                chunk.files = matchingChunk.files;
                chunk.label = matchingChunk.label;
                var index = chunks.indexOf(matchingChunk);
                if (index !== -1) {
                  chunks.splice(index, 1);
                  chunks.push(chunk);
                }
              }
            });

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = _this3.context.getComponents('watcher')[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var entry = _step7.value;

                try {
                  yield _this3.context.invokeComponent(entry, 'tick', [], [file]);
                } catch (error) {
                  _this3.context.report(error);
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          });

          return function tickCallback(_x11, _x12) {
            return _ref6.apply(this, arguments);
          };
        }();

        try {
          yield Promise.all(chunks.map(function (chunk) {
            return Promise.all(chunk.entries.map(function (chunkEntry) {
              return _this3.processFileTree(chunkEntry, files, oldFiles, useCache, false, tickCallback);
            }));
          }));
        } catch (error) {
          disposable.dispose();
          throw error;
        }

        var _iteratorNormalCompletion8 = true;
        var _didIteratorError8 = false;
        var _iteratorError8 = undefined;

        try {
          for (var _iterator8 = this.context.getComponents('watcher')[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
            var entry = _step8.value;

            try {
              yield this.context.invokeComponent(entry, 'ready', [], []);
            } catch (error) {
              this.context.report(error);
            }
          }
        } catch (err) {
          _didIteratorError8 = true;
          _iteratorError8 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion8 && _iterator8.return) {
              _iterator8.return();
            }
          } finally {
            if (_didIteratorError8) {
              throw _iteratorError8;
            }
          }
        }

        yield triggerRecompile();

        var debounceRecompile = (0, _sbDebounce2.default)(triggerRecompile, 20);
        watcher.on('change', function (filePath) {
          enqueue(function () {
            return _this3.processFileTree(filePath, files, oldFiles, useCache, true, tickCallback);
          });
          debounceRecompile();
        });
        watcher.on('unlink', function (filePath) {
          enqueue(function () {
            var filesDepending = [];
            files.forEach(function (file) {
              if (file.getImports().some(function (entry) {
                return entry.resolved === filePath;
              })) {
                filesDepending.push(file);
              }
            });
            return Promise.all(filesDepending.map(function (file) {
              return _this3.processFileTree(file.filePath, files, oldFiles, useCache, true, tickCallback);
            }));
          });
          debounceRecompile();
        });

        return disposable;
      });

      function watch(_x9) {
        return _ref4.apply(this, arguments);
      }

      return watch;
    }()
  }, {
    key: 'dispose',
    value: function dispose() {
      var _this4 = this;

      this.context.components.forEach(function (_ref7) {
        var component = _ref7.component,
            config = _ref7.config;
        return _this4.context.deleteComponent(component, config);
      });
      this.subscriptions.dispose();
    }
  }]);

  return Compilation;
}();

exports.default = Compilation;