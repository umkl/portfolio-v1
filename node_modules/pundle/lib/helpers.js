'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPundleConfig = exports.getLoadables = exports.load = exports.getCacheFilePath = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var getCacheFilePath = exports.getCacheFilePath = function () {
  var _ref = _asyncToGenerator(function* (directory) {
    var stateDirectory = _path2.default.join(_os2.default.homedir(), '.pundle');
    try {
      yield _sbFs2.default.stat(stateDirectory);
    } catch (error) {
      if (error.code === 'ENOENT') {
        yield mkdirp(stateDirectory);
      } else throw error;
    }

    var inputHash = _crypto2.default.createHash('sha1').update(directory).digest('hex');
    return _path2.default.join(stateDirectory, inputHash + '.json');
  });

  return function getCacheFilePath(_x) {
    return _ref.apply(this, arguments);
  };
}();

var load = exports.load = function () {
  var _ref2 = _asyncToGenerator(function* (request, rootDirectory) {
    var resolved = void 0;
    var mainModule = void 0;
    if (typeof request === 'string') {
      try {
        resolved = yield resolve(request, { basedir: rootDirectory });
      } catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
          var newError = new Error('Unable to resolve \'' + request + '\' from root directory. Make sure it\'s installed correctly');

          newError.code = 'MODULE_NOT_FOUND';
          throw newError;
        }
        throw error;
      }

      mainModule = require(resolved);
    } else mainModule = request;
    if (mainModule && mainModule.__esModule) {
      mainModule = mainModule.default;
    }
    if ((typeof mainModule === 'undefined' ? 'undefined' : _typeof(mainModule)) === 'object' && mainModule || (typeof request === 'undefined' ? 'undefined' : _typeof(request)) === 'object') {
      return mainModule;
    }
    if (!resolved) {
      throw new _pundleApi.FileMessageIssue('$root', 'Unable to resolve \'' + request + '\'');
    }
    throw new _pundleApi.FileMessageIssue(resolved, 'Module exported incorrectly');
  });

  return function load(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();

var getLoadables = exports.getLoadables = function () {
  var _ref3 = _asyncToGenerator(function* (loadables, rootDirectory) {
    var toReturn = [];
    for (var i = 0, length = loadables.length; i < length; i++) {
      var entry = loadables[i];

      var config = {};
      var component = void 0;
      if (Array.isArray(entry)) {
        var _entry = _slicedToArray(entry, 2);

        component = _entry[0];
        config = _entry[1];
      } else {
        component = entry;
      }
      var resolved = yield load(component, rootDirectory);
      if (!resolved || typeof resolved.$type !== 'string') {
        throw new _pundleApi.MessageIssue('Unable to load invalid component');
      }
      toReturn.push([resolved, config]);
    }
    return toReturn;
  });

  return function getLoadables(_x4, _x5) {
    return _ref3.apply(this, arguments);
  };
}();

var loadConfigFile = function () {
  var _ref4 = _asyncToGenerator(function* (rootDirectory, configFileName) {
    var contents = {};
    var loadFileConfig = false;
    var configPath = _path2.default.join(rootDirectory, configFileName || '.pundle.js');

    try {
      yield _sbFs2.default.stat(configPath);
      loadFileConfig = true;
    } catch (_) {}

    if (loadFileConfig) {
      var configModule = yield load(configPath, rootDirectory);
      if (typeof configModule === 'function') {
        contents = yield configModule();
      } else if ((typeof configModule === 'undefined' ? 'undefined' : _typeof(configModule)) === 'object' && configModule) {
        contents = configModule;
      }
      if (!contents) {
        throw new _pundleApi.MessageIssue('Invalid export value of config file in \'' + rootDirectory + '\'');
      }
    }
    return contents;
  });

  return function loadConfigFile(_x6, _x7) {
    return _ref4.apply(this, arguments);
  };
}();

var getPundleConfig = exports.getPundleConfig = function () {
  var _ref5 = _asyncToGenerator(function* (rootDirectory, a) {
    var config = {};

    var b = {};
    if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) !== 'object' || !a) {
      throw new Error('Config must be an object');
    }
    if (typeof a.enableConfigFile === 'undefined' || a.enableConfigFile) {
      b = yield loadConfigFile(rootDirectory, a.configFileName);
    }

    config.debug = merge('debug', false, b.debug, a.debug);
    config.entry = merge('entry', [], b.entry, a.entry);
    config.output = merge('output', {}, b.output, a.output);
    config.server = merge('server', {}, b.server, a.server);
    config.presets = merge('presets', [], b.presets, a.presets);
    config.watcher = merge('watcher', { usePolling: {}.hasOwnProperty.call(process.env, 'PUNDLE_WATCHER_USE_POLLING') }, b.watcher, a.watcher);
    config.components = merge('components', [], b.components, a.components);
    config.rootDirectory = merge('rootDirectory', null, a.rootDirectory, b.rootDirectory);
    config.replaceVariables = merge('replaceVariables', {
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV === 'production' ? 'production' : 'development')
    }, b.replaceVariables, a.replaceVariables);

    return config;
  });

  return function getPundleConfig(_x8, _x9) {
    return _ref5.apply(this, arguments);
  };
}();

exports.unserializeFiles = unserializeFiles;
exports.serializeFiles = serializeFiles;

var _sbFs = require('sb-fs');

var _sbFs2 = _interopRequireDefault(_sbFs);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _sbPromisify = require('sb-promisify');

var _sbPromisify2 = _interopRequireDefault(_sbPromisify);

var _pundleApi = require('pundle-api');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var resolve = (0, _sbPromisify2.default)(require('resolve'));
var mkdirp = (0, _sbPromisify2.default)(require('mkdirp'));

function unserializeFiles(unserializedFiles, filesMap) {
  unserializedFiles.forEach(function (serializedFile) {
    var file = _pundleApi.File.unserialize(serializedFile);
    filesMap.set(file.filePath, file);
  });
  return filesMap;
}
function serializeFiles(files) {
  return Array.from(files.values()).map(function (file) {
    return file.serialize();
  });
}

function merge(name, given) {
  for (var _len = arguments.length, values = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    values[_key - 2] = arguments[_key];
  }

  if (Array.isArray(given)) {
    return values.reduce(function (a, b) {
      if (!b) {
        return a;
      }

      return a.concat(b);
    }, given);
  }
  if ((typeof given === 'undefined' ? 'undefined' : _typeof(given)) === 'object' && given) {
    return Object.assign.apply(Object, [given].concat(values));
  }
  for (var i = 0, length = values.length; i < length; i++) {
    var value = values[i];
    if (typeof value !== 'undefined') {
      return value;
    }
  }
  if (given === null) {
    throw new Error('config.' + name + ' is required');
  }
  return given;
}