'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _babylon = require('babylon');

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _pundleApi = require('pundle-api');

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

var RESOLVE_NAMES = new Set(['require', 'require.ensure', 'require.resolve', 'module.hot.accept', 'module.hot.decline']);
var REQUIRE_NAMES = new Set(['require', 'require.resolve']);
var TIMER_NAMES = new Set(['clearImmediate', 'setImmediate']);

exports.default = (0, _pundleApi.createLoader)(function () {
  var _ref = _asyncToGenerator(function* (context, config, file) {
    if (!(0, _pundleApi.shouldProcess)(context.config.rootDirectory, file.filePath, config)) {
      return null;
    }

    var chunks = [];
    var imports = [];
    var injections = {
      unique: new Set(),
      imports: [],
      names: []
    };

    var ast = void 0;
    try {
      ast = (0, _babylon.parse)(file.getContents(), {
        sourceType: 'module',
        sourceFilename: file.filePath,
        plugins: ['jsx', 'flow', '*']
      });
    } catch (error) {
      if (error.loc) {
        throw new _pundleApi.FileIssue(file.getFilePath(), file.getContents(), error.loc.line, error.loc.column, error.message, 'error');
      } else {
        throw new _pundleApi.FileMessageIssue(file.getFilePath(), error.message);
      }
    }

    var processResolve = function processResolve(node) {
      var request = context.getImportRequest(node.value, file.filePath, node.loc);
      imports.push(request);
      node.value = request.id.toString();
    };
    var processReplaceable = function processReplaceable(path) {
      var name = Helpers.getName(path.node);
      if ({}.hasOwnProperty.call(context.config.replaceVariables, name)) {
        path.replaceWith(Helpers.getParsedReplacement(context.config.replaceVariables[name]));
        return;
      }

      if (TIMER_NAMES.has(name) && !injections.unique.has('timers') && !path.scope.hasBinding(name)) {
        injections.unique.add('timers');
        var fileImport = context.getImportRequest('timers', file.filePath);
        injections.imports.push(fileImport.id.toString());
        file.addImport(fileImport);
        injections.names.push(['setImmediate', 'clearImmediate']);
      } else if (name === 'Buffer' && !injections.unique.has('buffer') && !path.scope.hasBinding(name)) {
        injections.unique.add('buffer');
        var _fileImport = context.getImportRequest('buffer', file.filePath);
        injections.imports.push(_fileImport.id.toString());
        file.addImport(_fileImport);
        injections.names.push(['Buffer']);
      } else if ((name === 'process' || name.startsWith('process.')) && !injections.unique.has('process') && !path.scope.hasBinding('process')) {
        injections.unique.add('process');
        var _fileImport2 = context.getImportRequest('_process', file.filePath);
        injections.imports.push(_fileImport2.id.toString());
        file.addImport(_fileImport2);
        injections.names.push('process');
      }
    };
    (0, _babelTraverse2.default)(ast, {
      ImportDeclaration: function ImportDeclaration(path) {
        processResolve(path.node.source);
        file.useFeature(_pundleApi.FILE_FEATURES.ES_IMPORT);
      },
      ExportDeclaration: function ExportDeclaration() {
        file.useFeature(_pundleApi.FILE_FEATURES.ES_EXPORT);
      },
      CallExpression: function CallExpression(path) {
        if (path.node.callee.type === 'Import') {
          Helpers.processImport(context, file, chunks, path);
          return;
        }
        var name = Helpers.getName(path.node.callee);
        if (!RESOLVE_NAMES.has(name)) {
          return;
        }
        var parameter = path.node.arguments && path.node.arguments[0];
        if (!parameter || parameter.type !== (name === 'require.ensure' ? 'ArrayExpression' : 'StringLiteral')) {
          return;
        }
        if (REQUIRE_NAMES.has(name)) {
          if (path.scope.hasBinding('require')) {
            return;
          }
          file.useFeature(_pundleApi.FILE_FEATURES.CJS_IMPORT);
        }
        if (name === 'require.ensure') {
          Helpers.processEnsure(context, file, chunks, path);
        } else {
          processResolve(parameter);
        }
      },

      Identifier: processReplaceable,
      MemberExpression: processReplaceable
    });

    var compiled = (0, _babelGenerator2.default)(ast, {
      quotes: 'single',
      filename: file.filePath,
      sourceMaps: true,
      sourceFileName: file.filePath
    });
    var contents = compiled.code;
    var sourceMap = compiled.map;
    if (injections.imports.length) {
      var requires = injections.imports.map(function (entry) {
        return 'require(' + entry + ')';
      }).join(', ');
      var declarations = injections.names.reduce(function (decls, item, i) {
        if (!Array.isArray(item)) return decls;
        return decls.concat(item.map(function (e) {
          return e + ' = i' + i + '.' + e;
        }));
      }, []).join(',');
      var args = injections.names.map(function (entry, i) {
        return Array.isArray(entry) ? 'i' + i : entry;
      }).join(', ');
      contents = '(function(' + args + '){' + (declarations.length ? 'var ' + declarations + ';' : '') + '\n' + contents + '\n})(' + requires + ')';
      sourceMap = Helpers.incrementSourceMapLines(sourceMap, file.getFilePath(), contents, 1);
    }

    return {
      chunks: chunks,
      imports: imports,
      contents: contents,
      sourceMap: sourceMap
    };
  });

  return function (_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}(), {
  extensions: ['js', 'jsx']
});