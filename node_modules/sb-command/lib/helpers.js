'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PARAM_STRING_OPTIONAL_VARIADIC = exports.PARAM_STRING_REQUIRED_VARIADIC = exports.PARAM_STRING_OPTIONAL = exports.PARAM_STRING_REQUIRED = exports.OPTION_NAME = exports.DELIMETER = undefined;
exports.getDisplayName = getDisplayName;
exports.parseParameter = parseParameter;
exports.stringifyParameters = stringifyParameters;
exports.validateParameterPosition = validateParameterPosition;
exports.parseCommand = parseCommand;
exports.parseOption = parseOption;
exports.sortAliases = sortAliases;
exports.getClosestCommand = getClosestCommand;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDisplayName(argv) {
  return _path2.default.basename(argv[1] || 'node');
}

var DELIMETER = exports.DELIMETER = /,\s+|,|\s+/;
// ^ command with space or comma or space
var OPTION_NAME = exports.OPTION_NAME = /^(--[a-z0-9-]+)$|^(-[a-z0-9]+)$/i;
// ^ Include - or -- in captured to distinguish between two
var PARAM_STRING_REQUIRED = exports.PARAM_STRING_REQUIRED = /^<(\S+)>$/;
var PARAM_STRING_OPTIONAL = exports.PARAM_STRING_OPTIONAL = /^\[(\S+)\]$/;
var PARAM_STRING_REQUIRED_VARIADIC = exports.PARAM_STRING_REQUIRED_VARIADIC = /^<(\S+) *\.\.\.>$/;
var PARAM_STRING_OPTIONAL_VARIADIC = exports.PARAM_STRING_OPTIONAL_VARIADIC = /^\[(\S+) *\.\.\.\]$/;

function parseParameter(chunk) {
  var name = void 0;
  switch (true) {
    case PARAM_STRING_REQUIRED_VARIADIC.test(chunk):
      name = PARAM_STRING_REQUIRED_VARIADIC.exec(chunk)[1];
      return { type: 'required-variadic', name: name };
    case PARAM_STRING_REQUIRED.test(chunk):
      name = PARAM_STRING_REQUIRED.exec(chunk)[1];
      return { type: 'required', name: name };
    case PARAM_STRING_OPTIONAL_VARIADIC.test(chunk):
      name = PARAM_STRING_OPTIONAL_VARIADIC.exec(chunk)[1];
      return { type: 'optional-variadic', name: name };
    case PARAM_STRING_OPTIONAL.test(chunk):
      name = PARAM_STRING_OPTIONAL.exec(chunk)[1];
      return { type: 'optional', name: name };
    default:
      return null;
  }
}

function stringifyParameters(parameters) {
  var wrappers = {
    optional: ['[', ']'],
    required: ['<', '>']
  };
  return parameters.map(function (parameter) {
    var type = parameter.type.startsWith('optional') ? 'optional' : 'required';
    return '' + wrappers[type][0] + parameter.name + wrappers[type][1];
  });
}

function validateParameterPosition(parameter, index, parameters, chunks, prefix) {
  if (parameter.type.startsWith('required')) {
    var previousOptional = parameters.filter(function (i) {
      return i.type.startsWith('optional');
    });
    if (previousOptional.length) {
      throw new Error(prefix + ' because required parameter cannot appear after optional');
    }
  }
  if (parameter.type.endsWith('variadic')) {
    if (index !== chunks.length - 1) {
      throw new Error(prefix + ' because variadic must only appear at the end');
    }
  }
}

function parseCommand(given) {
  var name = void 0;
  var chunks = given.trim().split(DELIMETER);
  var parameters = [];
  var errorMessage = 'Command \'' + given + '\' is invalid';

  chunks.forEach(function (chunk, index) {
    if (index === 0) {
      name = chunk;
      return;
    }
    var parsed = parseParameter(chunk);
    if (!parsed) {
      throw new Error(errorMessage);
    }
    validateParameterPosition(parsed, index, parameters, chunks, errorMessage);
    parameters.push(parsed);
  });
  if (!name) {
    throw new Error(errorMessage);
  }

  return {
    name: name,
    parameters: parameters
  };
}

// NOTE: Stores - or -- in the aliases
function parseOption(option) {
  var chunks = option.trim().split(DELIMETER);
  var aliases = [];
  var errorMessage = 'Option \'' + option + '\' is invalid';
  var parameter = void 0;
  var processingAliases = true;

  chunks.forEach(function (chunk) {
    if (OPTION_NAME.test(chunk)) {
      if (!processingAliases) {
        throw new Error(errorMessage + ' because aliases must not appear after options');
      }
      var matched = OPTION_NAME.exec(chunk);
      aliases.push(matched[1] || matched[2]);
      return;
    }
    if (processingAliases) {
      processingAliases = false;
    }
    var parsed = parseParameter(chunk);
    if (!parsed) {
      throw new Error(errorMessage);
    }
    if (parsed.type.endsWith('variadic')) {
      throw new Error(errorMessage + ' because an option must not have variadic parameters');
    }
    if (parameter) {
      throw new Error(errorMessage + ' because an option must not have more than one parameter');
    }
    parameter = parsed;
  });

  if (!aliases.length) {
    throw new Error(errorMessage);
  }

  return {
    aliases: aliases,
    parameter: parameter || null
  };
}

function sortAliases(aliases) {
  return aliases.slice().sort(function (a, b) {
    var startPointA = a.substr(0, 2) === '--' ? 2 : 1;
    var startPointB = b.substr(0, 2) === '--' ? 2 : 1;
    if (startPointA < startPointB) {
      return -1;
    } else if (startPointA > startPointB) {
      return 1;
    }
    var lengthA = a.length;
    var lengthB = b.length;
    if (lengthA > lengthB) {
      return -1;
    } else if (lengthA < lengthB) {
      return 1;
    }
    return 0;
  });
}

function getClosestCommand(commands, chunks) {
  var closestCommand = null;
  var sortedCommands = commands.slice().sort(function (a, b) {
    return a.name.length - b.name.length;
  });
  for (var i = 0, length = sortedCommands.length; i < length; i++) {
    var currentCommand = sortedCommands[i];
    for (var j = chunks.length; j--;) {
      var currentName = chunks.slice(0, j + 1).join('.');
      if (currentName === currentCommand.name) {
        closestCommand = currentCommand;
        break;
      }
    }
  }
  return closestCommand;
}