'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _cliff = require('cliff');

var _cliff2 = _interopRequireDefault(_cliff);

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _camelcase = require('camelcase');

var _camelcase2 = _interopRequireDefault(_camelcase);

var _parser = require('./parser');

var _parser2 = _interopRequireDefault(_parser);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Command = function () {
  function Command() {
    _classCallCheck(this, Command);

    this.options = [];
    this.commands = [];
    this.appVersion = '';
    this.lastCommand = null;
    this.descriptionText = '';
    this.defaultCallback = null;

    this.option('--help', 'Print usage information');
    this.option('--version', 'Print version information');
  }

  _createClass(Command, [{
    key: 'default',
    value: function _default(callback) {
      (0, _assert2.default)(typeof callback === 'function', 'default callback must be a function');
      this.defaultCallback = callback;
      return this;
    }
  }, {
    key: 'version',
    value: function version(_version) {
      (0, _assert2.default)(_version && typeof _version === 'string', 'version must be a string');
      this.appVersion = _version;
      return this;
    }
  }, {
    key: 'description',
    value: function description(descriptionText) {
      (0, _assert2.default)(descriptionText && typeof descriptionText === 'string', 'descriptionText must be a string');
      this.descriptionText = descriptionText;
      return this;
    }
  }, {
    key: 'command',
    value: function command(givenCommand, description) {
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      (0, _assert2.default)(typeof givenCommand === 'string', 'command must be a string');
      (0, _assert2.default)(typeof description === 'string', 'description must be a string');
      (0, _assert2.default)(!callback || typeof callback === 'function', 'callback must be a function');

      var _Helpers$parseCommand = Helpers.parseCommand(givenCommand),
          name = _Helpers$parseCommand.name,
          parameters = _Helpers$parseCommand.parameters;

      if (this.commands.find(function (i) {
        return i.name === name;
      })) {
        throw new Error('Command \'' + name + '\' is already registered');
      }
      this.lastCommand = name;
      this.commands.push({ name: name, parameters: parameters, description: description, callback: callback });
      return this;
    }
  }, {
    key: 'option',
    value: function option(_option, description) {
      var _this = this;

      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      (0, _assert2.default)(typeof _option === 'string', 'option must be a string');
      (0, _assert2.default)(typeof description === 'string', 'description must be a string');

      var _Helpers$parseOption = Helpers.parseOption(_option),
          aliases = _Helpers$parseOption.aliases,
          parameter = _Helpers$parseOption.parameter;

      if (this.options.find(function (i) {
        return i.aliases.find(function (j) {
          return aliases.indexOf(j) !== -1;
        }) && i.command === _this.lastCommand;
      })) {
        throw new Error('parts of option \'' + _option + '\' are already registered');
      }
      this.options.push({ aliases: aliases, parameter: parameter, description: description, defaultValue: defaultValue, command: this.lastCommand });
      return this;
    }
  }, {
    key: 'parseArgv',
    value: function parseArgv(given) {
      var _parseArgv2 = (0, _parser2.default)(given, this.commands, this.options),
          options = _parseArgv2.options,
          command = _parseArgv2.command,
          parameters = _parseArgv2.parameters,
          rawParameters = _parseArgv2.rawParameters;

      var mergedOptions = {};
      options.forEach(function (entry) {
        entry.option.aliases.forEach(function (givenAlias) {
          var alias = givenAlias.slice(givenAlias.slice(0, 2) === '--' ? 2 : 1);
          mergedOptions[alias] = entry.value;
          mergedOptions[(0, _camelcase2.default)(alias)] = entry.value;
        });
      });
      return { options: mergedOptions, command: command, parameters: parameters, rawParameters: rawParameters };
    }
  }, {
    key: 'process',
    value: function (_process) {
      function process() {
        return _process.apply(this, arguments);
      }

      process.toString = function () {
        return _process.toString();
      };

      return process;
    }(function () {
      var _this2 = this;

      var argv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.argv;

      var result = void 0;
      try {
        result = this.parseArgv(argv);
      } catch (error) {
        console.log('Error:', error.message);
        this.showHelp(argv, error.parameters || []);
        process.exit(1);
        return Promise.resolve();
        // ^ Necessary for flow
      }
      var _result = result,
          options = _result.options,
          command = _result.command,
          parameters = _result.parameters,
          rawParameters = _result.rawParameters;

      if (parameters.length === 0 && options.version) {
        console.log(this.appVersion);
        process.exit(0);
      } else if (parameters.length === 0 && options.help) {
        this.showHelp(argv, rawParameters);
        process.exit(0);
      } else if (!parameters.length && this.defaultCallback) {
        // $FlowIgnore: We validate that defaultCallback is not null here flow don't worry
        return new Promise(function (resolve) {
          return resolve(_this2.defaultCallback(options, parameters));
        });
      } else if (!command || !command.callback) {
        if (parameters.length) {
          console.log('Error: Invalid subcommand', parameters[0]);
        }
        this.showHelp(argv, rawParameters);
        process.exit(1);
        return Promise.resolve();
        // ^ Necessary for flow
      }
      return new Promise(function (resolve) {
        // $FlowIgnore: Command is not null here, flow thinks otherwise
        resolve(command.callback.apply(command, [options].concat(parameters)));
      });
    })
  }, {
    key: 'generateHelp',
    value: function generateHelp() {
      var argv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.argv;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var chunks = ['Usage: ' + Helpers.getDisplayName(argv) + (this.commands.length ? ' [command...]' : '') + (this.options.length ? ' [options]' : '')];
      if (this.descriptionText) {
        chunks.push('');
        chunks.push(this.descriptionText);
      }

      function appendOptions(options) {
        chunks = chunks.concat(_cliff2.default.stringifyRows(options.map(function (option) {
          var aliases = Helpers.sortAliases(option.aliases);
          var params = Helpers.stringifyParameters(option.parameter ? [option.parameter] : []);
          return ['  ', aliases.join(', '), '  ', params.join(' '), '  ', option.description];
        })));
      }

      if (this.options.length) {
        chunks.push('');
        chunks.push('Global Options:');
        appendOptions(this.options.filter(function (o) {
          return o.command === null;
        }));
      }

      var closestCommand = Helpers.getClosestCommand(this.commands, parameters);
      if (closestCommand) {
        var commandOptions = this.options.filter(function (o) {
          return o.command === closestCommand.name;
        });
        if (commandOptions.length) {
          chunks.push('');
          chunks.push('Command Options:');
          appendOptions(commandOptions);
        }
      }

      var subCommands = this.commands;
      if (closestCommand) {
        var closestCommandParams = Helpers.stringifyParameters(closestCommand.parameters);
        subCommands = subCommands.filter(function (c) {
          return c.name.startsWith(closestCommand.name) && c.name !== closestCommand.name;
        });
        chunks[0] = 'Usage: ' + Helpers.getDisplayName(argv) + ' ' + closestCommand.name.split('.').join(' ') + (closestCommandParams ? ' ' + closestCommandParams.join(' ') : '') + (this.options.length ? ' [options]' : '');
        if (subCommands.length) {
          chunks[0] += '\nUsage: ' + Helpers.getDisplayName(argv) + ' ' + closestCommand.name.split('.').join(' ') + (subCommands.length ? ' [subcommand...]' : '') + (this.options.length ? ' [options]' : '');
        }
      }
      if (subCommands.length) {
        chunks.push('');
        chunks.push((closestCommand ? 'Subc' : 'C') + 'ommands:');
        chunks = chunks.concat(_cliff2.default.stringifyRows(subCommands.map(function (command) {
          var params = Helpers.stringifyParameters(command.parameters);
          return ['  ', command.name.split('.').join(' '), '  ', params.join(' '), '  ', command.description];
        })));
      }
      return chunks.join('\n');
    }
  }, {
    key: 'showHelp',
    value: function showHelp() {
      var argv = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.argv;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      console.log(this.generateHelp(argv, parameters));
    }
  }]);

  return Command;
}();

var _command = new Command();
// $FlowIgnore: Custom property
_command.Command = Command;

module.exports = _command;