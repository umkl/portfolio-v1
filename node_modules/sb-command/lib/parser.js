'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var OPTION_SHORT_MULTI = /^-([a-z0-9]{2,})$/i;

var OPTION_COMPRESSED = /^(--[a-z0-9-]+)=(.+)$|^(-[a-z0-9]+)=(.+)$/i;

function getOptionByAlias(options, alias, rawParameters) {
  var validationPrefix = rawParameters.join('.');
  var foundOption = options.find(function (option) {
    return option.aliases.indexOf(alias) !== -1 && (!option.command || validationPrefix.indexOf(option.command) === 0);
  });
  if (foundOption) {
    return foundOption;
  }
  throw new Error('Option ' + alias + ' is not recognized');
}

function generateError(message, parameters) {
  var error = new Error(message);
  // $FlowIgnore: Custom prop
  error.parameters = parameters;
  return error;
}

function parse(given, commands, options) {
  var _parsedParameters;

  var parsedParameters = [];
  var rawParameters = [];
  var parsedOptions = [];

  var lastOption = null;
  var argv = given.slice(2);
  for (var i = 0; i < argv.length; i++) {
    var chunk = argv[i];
    if (chunk === '--') {
      parsedParameters = parsedParameters.concat(argv.slice(i + 1));
      break;
    }
    if (chunk.startsWith('-')) {
      if (lastOption) {
        if (lastOption.option.parameter && !lastOption.value) {
          throw generateError('Option ' + chunk + ' expects a value', rawParameters);
        }
        parsedOptions.push(lastOption);
        lastOption = null;
      }
      if (OPTION_SHORT_MULTI.test(chunk)) {
        // Expand -asd to -a -s -d in argv
        var matched = OPTION_SHORT_MULTI.exec(chunk);
        argv.splice.apply(argv, [i, 1].concat(_toConsumableArray(matched[1].split('').map(function (e) {
          return '-' + e;
        }))));
        i--;
        continue;
      }
      if (OPTION_COMPRESSED.test(chunk)) {
        // Expand --bee=sea / -a=b to [--bee, sea]
        var _matched = OPTION_COMPRESSED.exec(chunk);
        argv.splice(i, 1, _matched[1] || _matched[3], _matched[2] || _matched[4]);
        i--;
        continue;
      }
      lastOption = {
        name: chunk,
        value: null,
        option: getOptionByAlias(options, chunk, rawParameters)
      };
    } else {
      if (!lastOption) {
        rawParameters.push(chunk);
        continue;
      }
      if (lastOption.option.parameter && !lastOption.value) {
        lastOption.value = chunk;
        parsedOptions.push(lastOption);
        lastOption = null;
      } else {
        rawParameters.push(chunk);
      }
    }
  }

  if (lastOption) {
    if (lastOption.option.parameter && !lastOption.value) {
      throw generateError('Option ' + lastOption.name + ' expects a value', rawParameters);
    }
    parsedOptions.push(lastOption);
  }

  var command = null;

  var _loop = function _loop(_i) {
    var currentName = rawParameters.slice(0, _i + 1).join('.');
    command = commands.find(function (entry) {
      return entry.name === currentName;
    });
    if (command) {
      var _parsedParameters2;

      (_parsedParameters2 = parsedParameters).unshift.apply(_parsedParameters2, _toConsumableArray(rawParameters.slice(_i + 1)));
      return 'break';
    }
  };

  for (var _i = rawParameters.length; _i--;) {
    var _ret = _loop(_i);

    if (_ret === 'break') break;
  }

  if (command) {
    var notEnough = false;
    var availableParameters = parsedParameters.slice();
    parsedParameters = [];
    for (var _i2 = 0, length = command.parameters.length; _i2 < length; _i2++) {
      var parameter = command.parameters[_i2];
      var value = availableParameters.shift();
      if (!value && parameter.type.startsWith('required')) {
        notEnough = true;
        break;
      } else if (parameter.type.endsWith('variadic')) {
        parsedParameters.push((value ? [value] : []).concat(availableParameters.slice()));
        availableParameters.length = 0;
        break;
      } else if (value) {
        parsedParameters.push(value);
      }
    }
    // Do not throw these errors when user asks --help
    if (!parsedOptions.some(function (o) {
      return o.option.aliases.indexOf('--help') !== -1;
    })) {
      if (notEnough) {
        throw generateError('Not enough parameters for command: ' + command.name.split('.').join(' '), rawParameters);
      } else if (availableParameters.length) {
        throw generateError('Too many parameters for command: ' + command.name.split('.').join(' '), rawParameters);
      }
    }
  } else (_parsedParameters = parsedParameters).unshift.apply(_parsedParameters, rawParameters);

  // Process the bool options and fill defaults
  for (var _i3 = 0, _length = parsedOptions.length; _i3 < _length; _i3++) {
    var entry = parsedOptions[_i3];
    if (!entry.option.parameter) {
      entry.value = true;
    }
  }

  // Add defaults
  var validationPrefix = rawParameters.join('.');
  options.forEach(function (option) {
    if (parsedOptions.find(function (e) {
      return e.option === option;
    })) {
      return;
    }
    if (option.command && validationPrefix.indexOf(option.command) !== 0) {
      return;
    }

    var defaultValue = option.defaultValue;
    if (defaultValue === null) {
      if (option.parameter) {
        defaultValue = option.parameter.type.endsWith('variadic') ? [] : '';
      } else defaultValue = false;
    }
    parsedOptions.push({
      option: option,
      name: '',
      value: defaultValue
    });
  });

  return {
    options: parsedOptions,
    command: command,
    parameters: parsedParameters,
    rawParameters: rawParameters
  };
}